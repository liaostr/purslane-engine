## [Chinese Document](https://github.com/obhen233/purslane-engine/blob/master/%E4%B8%AD%E6%96%87%E6%8F%8F%E8%BF%B0.md)|English Document ##
# I Standard Rules Expression:#
1. **Elements:** A set of [] means an Element, Element includes Node and Leaf.Node makes up by Nodes,Leaves.Leaf contains Functions.
2. **Rules:** Relationships between Elements are "and" or "or". The following is defined: If an element is composed entirely of Node, then the relationship between Nodes is "or". If there is a leaf, then between elements the relationship is "and".
3. **Unusual Element:** Bud is an Element that always returns true.This is to deal with the fact that the elements are completely composed of Node, but the nodes must be connected with "and". The Root element is the root element, all The starting point of the element.
4. **Function:**$add function name represents a function, the function implementation is implemented by a third-party language. Example: $fun function inversion Add an exclamation mark in front of the function to invert the function i.e !$func, this does not support negation of the element.
5. **Function parameters:** Parameters divided into parameter values and reference values, the parameter values are in the front, the reference values are in the back, and the parameter values are wrapped by the ## key. Example: #param1# Multiple parameters #param1#, #param2#, no parameters or default Parameter, parameter value is set to null. The default parameter is param and there is only one. The default and custom values are mutually exclusive. Customization cannot be used by default, and customization cannot be used by default.
6. **Function reference value:** The reference value is wrapped by {}, {key:value}, has no reference value, is blanked, uses the default reference value and is initialized without assignment, and is blank. For example, $fun(#param1#), using the base value and assigning values ignores the key case: $fun(#param1#,{:1}) or $fun(#param1#,{1}). When the initial value of the reference value is formatted with a colon, the separated colon cannot be omitted. For example, $dateFun(#param1#,{:2020-01-01 00:00:00}), the default reference value has one and only one. The default and custom values are mutually exclusive.
7. **Base value Unusual type:** used between list element and element, for example {base1:1, 2, 3, 4, 5} represents a list value, dictionary value (Map) Example {base1:k1|v1,k2| V2, k3|v3}, you can also customize the reference value format. Time format default yyyy-MM-dd HH:mm:ss.
8.  **How to use Expression:** a legal Expression likes [[[$func1()][$func2({1})][$func3({:2020-01-01 00:00:00})]][[[$func1()][$func4(#param1#)]][[$func5(#param2#,#param3#)]]][[[$func6(#param4#,{base1:1},$func7(#param5#,{base2:},{base3:k1|v1,k2|v2})][$func8({base4:1,2,3,4,5})]][[$func9()][$func10()][!$func4(#param1#),$func9()]][]]]
An empty representation has no parameters or uses default parameters. The reference value can be directly assigned to the initial value in the expression, or it can be passed as an expression parameter. func1.param represents the default parameter of the function func1. param func7.base2 represents the function func7 The reference value base2, func6 reference value is base1,value is 1, the reference value of func8 is a list, and func7.base3 is a dictionary value.
The above expression Root consists of three Nodes. The first Node consists of two Leafs. The Leaf and Leaf are in "AND" relationship. The second Node is composed of two Nodes. The two are "OR" relationships. It consists of two Nodes, but there is a [] in it to indicate that the relationship between the two Nodes is "AND", and the relationship between the three Nodes is "OR".
# II Use in java #
1. **Element:** The element has 4: Node Leaf Buds and Root,these are inherited from Element . A Node has multiple Elements. Root inherited from Node. Leaf contains a collection of rules, which is the end of all Nodes. The relationship between the rules in Leaf is "AND".Bud is a unusual Leaf that always returns True. If the elements in a Node are Nodes, then these Nodes are connected to each other By "OR". If elements have one or more Leaves then those elements are joined with "AND". elements relationship between each other are all short-circuited,Leaf has a default return value,If there is no Rule under Leaf, Method excute will return the value of this default value. The default is false.
2. **Rule:** rule is a customizable rule with two default parameters param and base. This is the most complex and flexible. All logic is basically executed on the rule.By inheriting the Rule, you can customize a Rule. The custom Rule needs to implement the "excute" method. There are two values in the Rule. The value is the reference value. This value is used as the reference. For example, if the condition is greater than 3, the 3 is the reference value. As a basis for judgment, the reference value can also be dynamically maintained and calculated. The parameters are passed in, as a condition for judgment, the process of judgment is in excute. Returns a boolean type.The excuteMsg method is a method that returns a custom result. It can be overwritten if necessary. When the rule's excute method evaluates to flase, you need to return some custom results for the next step. You can override this method. The default is to return a character information.Nrule is the inverse of the Rule object, you can put a Rule object in  initialization.
3. **Get the provided rule:**The static method getFeildInfo in RuleProducer will return the list of available rule names: function desc: rule description, description language: lang(i18n) field description, name description in the field description func7.base2 simpleName example Base2 fieldType is an annotation type identifier that identifies whether the field is a parameter or a baseline value. Value is unique to the reference value. If the set default value is both the set default value. The other is empty. Pass in when you need to match the rules.
4. **Root object management:** Root has a unid to identify the unique root, and the unid+&+ stored in the framework is based on the alphabetic order of the incoming parameters +& divided string, after 32-bit md5 uppercase value,  The incoming parameters mean that all the param+ bases that need to be dynamically configured can be obtained through the RootProductor method. These two interfaces are returned for the client system to combine the rules engine.The rootProducer can be initialized with xml, properties, annotations, and storePlugin. In the same way, there is also an interface to get the interface that adds and deletes the root, and the interface getRootsParam that the corresponding root needs.
5. **StorePlugin:** This is a plug-in for root object storage management. The stand-alone mode can be arbitrarily selected for storage. For cluster mode, it should be implemented in synchronous mode (implementing SynchStorePlugin), or it can be managed by root. If Root initializes once and basically no changes (write dead rules), any management mode can be used. It is recommended to use Redis to manage Root and implement SynchStorePlugin.
6. **Call:** Engine.doExcute method, pass in the param map composed of the expression /unid/root+ parameter. The key in the specific map is composed of the parameter name returned by getRootsParam in RootProducer.The execution result will be returned. The general case is a String. It can also be customized by the developer. When customizing the rule, rewrite the Rule's excuteMsg method.DoExcute can be executed throughs a root-annotated class, a unid (after registering the Root object), a root object, or a standard regular expression.
7. **Annotations:** There are two types of annotations. One is the use of the framework (under the framework package), and the other is the use of annotation rules (under the application package)
   - **Framework Package:**  
     1. **@DateFormat** Used in the Rule reference value or parameter, format the time format into a string and format the string into time. The default is yyyy-MM-dd HH:mm:ss
     2. **@Formator** used in the benchmark reference value or parameter value is a Formator class, this is to customize the formatting type, formatted into the standard rule expression, can also be reversed into objects from the standard regular expression. Inherit com.sunbox.formator.Formator, implement parse and format 
     3. **@Function** is used on the Rule class to format the name. If you do not use the default Rule name, the first letter of the class name is the expression function name. Require the only item in the project.
     4. **@NoBase** is used on the Rule class to indicate that the Rule is a rule with no reference value, for example, the date is greater than the current time.
     5. **@NoParam** is used on the Rule class to indicate that the Rule is a rule with no parameters, such as a limited day.
     6. **@RuleBase** is used on the custom field in the Rule to indicate that this field is a reference value. The value value is the name of this field in the standard expression. The default is the field name. Base is the default value of this field. When initializing, the base will be assigned to this field of this object. The get set must be implemented.
     7. **@RuleParam** is used on the custom field in the Rule to indicate that this field is a parameter value. The value value is the name of this field in the standard expression, the default is the field name.
     8. **@Description** Description is used in the custom field, Rule class,Description of this field or Rule desc is the description text, lang refers to the corresponding value of I18n, default is Chinese zh_cn.  
   - **Application Package:**  
     1. **@IfNull** is used on the Leaf. If there is no Rule under Leaf, it means that the value returned by the excute method is true or false.
     2. **@Leaf** is placed on a class that inherits from Element, indicating what Rule is in the Leaf.
     3. **@Node** placed on the class that inherits Element, which indicates which Node or Leaf or Bud is in this Node.
     4. **@Root** indicating that this is a Root element, unid is unique identifier.
     5. **@Rule** is placed in the annotation Leaf to indicate that there is a Rule not under the Leaf to indicate whether the rule is negated. The default is not reversed.
8. **I18n:**The easy way is through the Description annotation, and one way is through I18n.properies.This function.zh_cn indicates what the Chinese description of this function is. If it can't find function.zh it will go to the function key function.param.zh_cn indicates the Chinese description of the function function param. If you can't find it, you will find it. Function.param .The priority is First Description then function.zh_cn Last function, nothing returns an empty string.
9.ExpressionUtil provides some ways to convert standard rules to Root.

**This regular expression is still under development.Please use it after careful testing.**
Demo in  [https://github.com/obhen233/engineDemo.git](https://github.com/obhen233/engineDemo.git)


